**9 差分隐私和计算复杂度**

迄今为止，我们对差异性隐私的讨论忽略了计算复杂度的问题，从而使（数据库）管理者和攻击者在计算上都不受限制。 实际上，管理者和敌手都可能受到计算的限制。
   将自己限制在计算受限制的管理者中会限制管理者的能力，从而难以实现差分隐私。 确实，我们将展示一类计数查询的示例，在标准复杂性理论假设下，即使已知效率不高的算法（例如$$SmallDB$$和私有乘积权重），也不允许有效生成合成数据库。 粗略地说，数据库行是数字签名，使用管理者无法访问的密钥进行签名。 直觉是，合成数据库中的任何行都必须从原始副本中复制（侵犯隐私），或者必须是新消息的签名（即伪造），这违反了数字签名方案的不可伪造性。 不幸的是，这种情况并不仅限于基于数字签名的示例（可能是人为设计的）：创建一个相对准确的双向边际的合成数据库甚至更加困难。从积极的一面来看，给定一组查询Q和一个具有从域 X绘制的行的n行数据库，可以在$n$，| $X$ |和| $Q$ |中按时间多项式生成综合数据库。

如果我们放弃合成数据库的目标，满足于一种数据结构，从这种结构中我们可以获得每个查询的相对准确的近似答案，情况就有趣多了。事实证明，这个问题与追踪叛徒问题密切相关，追踪叛徒的目的是在向付费用户分发数字内容的同时阻止盗版

如果对手受限于多项式时间，那么就更容易实现差别隐私。事实上，非常强大的安全功能评估概念提供了一种自然的方式来避免信任的馆长(同时给出比随机响应更好的准确性)，以及一种自然的方式来允许多个信任的馆长(由于法律原因，他们不能共享他们的数据集)响应关于什么是有效的合并数据集的查询。简而言之，安全函数求值是一种加密原语，它允许n个参与方$p_1、p_2、...，p_n$，其中少于一些固定分数是有故障的(分数根据故障的类型而变化；对于“诚实但好奇”的故障，分数为1)，合作计算任何函数$f(x_1，...x_n)$，其中$x_i$是$p_i$的输入或值，以这种方式，故障方的任何联盟都不能中断计算或了解比从函数输出和联盟成员的值所能推断的更多的关于非故障方的值。这两个属性传统上称为正确性和私密性。这种隐私概念，让我们称之为$SFE$隐私，与差分隐私非常不同。设$V$为故障方持有的一组值，设$p_i$为非故障方。$SFE$隐私允许故障方学习$xi$,如果 $x_i$能由$V$ ∪ ${ f(x_1...，x_n)}$；差分隐私不允许$$f(x_1，...，x_n)$$。但是，用于计算函数$f$的安全功能评估协议可以很容易地被修改以获得$f$的差分隐私协议，简单地通过定义一个新的函数$$g$$，它是将拉普拉斯噪声$$Lap(\Delta f/ε)$$加到$f$的值上的结果。原则上，安全函数评估允许对$g$进行评估。由于g是差分私有的，并且应用于$g$的$$SFE$$隐私属性表明，对于不能从$$g(x1，.。。，xn)$$与$$V$$一起，只要有缺陷的玩家被限制在多项式时间内，就可以确保不同的隐私。因此，安全功能评估允许实现差分隐私的计算概念，即使没有可信任的管理员，与可信任的管理员相比也不会损失准确性。特别是，在没有可信的管理员情况下，计数查询可以用恒定的期望错误来回答，同时确保计算差异隐私。我们将会看到，如果没有加密，误差必须是$$\Omega (n^\frac{1}{2})$$，证明了在多方情况下，计算假设可证明准确性。

**9.1 多项式时间管理者**

​	在这一节中，我们展示了在标准的密码学假设下，创建一个合成的数据库在计算上是很困难的，这个数据库将为一个适当选择的计数查询类产生准确的答案，同时确保哪怕是最小的隐私概念。

​	这个结果有几个扩展；例如，对于查询集很小(但是数据空间仍然很大)的情况，以及数据空间很小(但是查询集很大)的情况。此外，对于某些自然的查询族，例如对应于连词的查询族，已经获得了类似的否定结果。

​	我们将使用合成这个术语来表示以保护隐私的方式生成合成数据库的过程。因此，本节的结果涉及合成的计算难度。我们对隐私的概念将远远弱于差分隐私，因此合成的难度意味着以不同的私有方式生成合成数据库的难度。具体来说，我们会说，如果很难避免输入项全部泄漏，合成就很难。也就是说，有些项目总是完全暴露。

​	请注意，相比之下，如果泄漏一些输入项不被认为是侵犯隐私，那么合成很容易通过释放输入项的随机选择子集来实现。这个“合成数据库”的效用来自于抽样界限:这个子集很有可能会保持效用，即使是对于大量的计数查询。

​	当引入复杂性假设时，我们需要一个安全参数来表示大小；例如，集合的大小、消息的长度、解密密钥中的位数等等，以及表示计算难度。安全参数表示为$$κ$$，代表“合理”的大小和努力。例如，假设在安全参数中穷举搜索大小为(任意固定)多项式的集合是可行的。

​	计算复杂性是一个渐进的概念——我们关心的是任务的难度如何随着对象(数据世界、数据库、查询族)的增长而增加。因此，举例来说，我们需要考虑的不仅仅是单一规模的数据库上的分布(我们在本专著的其余部分中一直称之为n)，而是由安全参数索引的分布集合。与此相关，当我们引入复杂性时，我们倾向于“软化”声明:伪造签名并非不可能——一个人可能是幸运的！相反，我们假设没有一个有效的算法以不可忽略的概率成功，其中“有效”和“不可忽略”是根据安全参数定义的。在我们的直观讨论中，我们将忽略这些细微之处，但会将它们保留在形式定理陈述中。

​	非正式地说，数据库的分布是很难合成的(就某个查询家族$Q$而言)，如果对于任何有效的(所谓的)合成者，从分布中提取的数据库上的大概率，至少一个数据库项目可以从所谓的合成者的输出中提取。当然，为了避免繁琐，我们还会要求，当这个泄露的项被从输入数据库中排除时(比如说，被一个随机的不同项替换)，它能够从输出中提取出来的概率非常小。这意味着任何有效的(所谓的)合成者确实在很大程度上损害了输入项的隐私。

​	下面的定义9.1将正式确定我们对合成者的效用要求。这里有三个参数，$\alpha$描述精度要求（在$alpha$范围内被认为是准确的）；$\gamma$描述了在一个成功的合成中允许查询不准确的部分；$\beta$是失败的概率。

​	对于产生合成数据库的算法$A$,我们说对于查询集$Q$如果$|q(A(x))-q(x)|<=\alpha$,对于查询$q$∈$Q$中$1-\gamma$的部分，则称输出$A(x)$是$(\alpha,\gamma)$-精确的。

定义9.1$((\alpha,\beta,\gamma))$-效用  设$Q$为一组查询，$X$为一个数据域。一个合成者对于关于$Q$和$X$的$n$项数据库具有$(\alpha,\beta,\gamma)-$效用，如果对任何$n$项数据库$x$:
$$
Pr[A(x)\ is\ (\alpha,\gamma)-accurat\ for\ Q]>=1-\beta
$$
其中概率实在A的硬币上。

​	设$Q=\{Q_n\}\ n=1,2,...$是一个查询族合集，$X=\{X_n\}\ n=1,2,...$是一个数据域合集。如果一个算法的运行时间是$$poly(n，log(|Q_n|)，log(|X_n|)$$，那么这个算法就是高效的。

​	在下一个定义中，我们描述了一系列分布很难合成意味着什么。更具体地说，我们将说很难生成提供$$(α，γ)$$精度的合成数据库意味着什么。像往常一样，我们必须使这成为一个渐近的陈述。

定义9.2$(\mu，α，β，γ，Q)$-难以合成的数据库分布。设$$Q = \{Q_n\}\ n=1，2，...$$为一个查询族全体，$$X =  \{X_n\}\ n=1，2，...$$为一个数据宇宙全体，让$$\mu，α，β，γ ∈ [0，1]$$。假设$n$是数据库大小，$D$是分布的集合，其中$D_n$是来自$Xn$的$n + 1$个项目的集合。

​	我们用$$(x，i，x′_i)$$~$D_n$示选择一个$n$个元素数据库的实验，一个从$$[n]$$中均匀选择的索引$i$，和一个来自$X_n$附加元素$x'_i$。来自$$D_n$$的一个样本给了我们一对数据库:$x$和用$x'_i$替换$x$的第$i$个元素的结果（在规范排序下）。因此，我们认为$D_n$指定了$n$项数据库(及其邻居)上的分布。

​	我们说$D$是$$(\mu，α，β，γ，Q)$$-难以合成的，如果存在一个有效的算法$T$，那么对于任何所谓的有效合成者$A$，以下两个条件成立:

​	1. 对于概率$1-\mu$超过数据库$x$~$D$的选择和$A$与$T$的硬币，如果$$A(x)$$在查询的$1-\gamma$部分中保持$\alpha$效用，那么$T$可以从$$A(x)$$恢复$x$的一行:
$$
Pr\\(x,i,x'_i) \  D_n\\coin\ flips\ of\ A,T\\ [(A(x)\ maintains (\alpha,\beta,\gamma)-utility)\ and\ x∩T(A(x))=\emptyset]<=\mu
$$

2.  对于每一个有效的算法$$A$$，对于每一个$$i ∈  [n]$$，如果我们从$$D$$中抽取$$(x，i，x′_i)$$，并用来自$x'$的$x'_i$替换$x_i$，$T$不能从$$A(x′)$$中抽取$_i$，除非概率很小:

$$
Pr\\(x,i,x'_i) \  D_n\\coin\ flips\ of\ A,T\\ [x_i∈T(A(x'))]<=\mu
$$

​	稍后，我们将对产生任意概要的离线机制感兴趣，不一定是合成数据库。在这种情况下，我们将对相关的难以净化的概念感兴趣(而不是难以合成)，为此我们简单地放弃了$A$生成合成数据库的要求。

**9.2 一些难以合成的分布**

我们现在构建了三个难以合成的分布。

​	签名方案由三种(可能是随机的)算法(生成、签名、验证)组成:

​	$Gen : 1^N→ \{(SK,VK)_n\}\ n=1,2,...$用于生成由(秘密)签名密钥和(公开)验证密钥组成的密钥对。它只取一元书写的安全参数$$κ  ∈ N$$作为输入，从$$(SK，VK)_k$$产生一对，分布在(签名，验证)由κ索引的密钥对上；我们让我们让$$p_s(κ),p_v(κ),ℓ_s(κ)$$分别表示签名密钥、验证密钥和签名的长度。

​	$Sign : SKκ× \{0,1\}^ℓ(κ)→ \{0,1\}^ℓs(κ)$ 将来自$$(SK，vk)κ$$中的签名密钥和长度为$$ℓ(k)$$的信息$m$作为输入，并在$$m$$上产生签名；

​	 $ Verify : VKκ× \{0,1\}^∗× \{0,1\}^ℓ(κ)→ \{0,1\}$  将验证密钥、字符串σ和长度为ℓ(κ)的消息m作为输入，并检查σ在给定的验证密钥下是否确实是m的有效签名。

​	密钥、消息长度和签名长度都是κ中的多项式。

​	所需安全性的概念是，给定有效(消息、签名)对的任何多项式数，很难伪造任何新的签名，甚至是先前签名的消息的新签名(回想签名算法可能是随机化的，因此同一消息在同一签名密钥下可能存在多个有效签名)。这种签名方案可以由任何单向函数构成。非正式地说，这些函数很容易计算——$$f(x)$$可以用$x$长度(位数)的时间多项式计算，但很难反演:对于每个概率多项式时间算法，在安全参数$k$的多项式时间中运行，在$f$的域中随机选择的$x$上，找到$$f(x)$$的任何有效原象的概率比$k$中任何多项式的逆增长得更慢.

**难以合成的分布1**:固定一个任意签名方案。计数查询的集合$$Qκ$$对于每个验证密钥$$vk ∈  VKκ$$包含一个计数查询$q$$_v$$_k$。数据宇宙$$Xκ$$由用$$VKκ$$中的密钥签名的长度为ℓ(κ)的消息的所有可能(消息、签名)形式对的集合组成。

​	数据库上的分布$$D_κ$$由以下抽样程序定义。运行签名方案生成器$$Gen(1^κ)$$获得$$(sk，vk)$$。在$\{0,1\}^ℓ$$^κ$随机选择$$n  =  κ$$条消息，对每条消息运行签名过程，获得一组n(消息，签名)对，全部用密钥$vk$签名。这是数据库x。请注意，数据库中的所有消息都使用相同的签名密钥进行签名。

 	A数据宇宙项$$(m，σ)$$满足谓词$q_v$$_k$，并且仅当$$Verify(vk，m，σ) =  1$$，即$$σ$$是根据验证密钥$$vk$$的$$m$$的有效签名。

​	设$$x∈_RDκ$$为数据库，设$$sk$$为使用的签名密钥，对应验证密钥$$vk$$。假设合成器产生了$$y$$，那么在$$vk$$下$$y$$的几乎所有行都是有效的签名(因为查询$$vk$$的$$x$$的分数是1)。根据签名方案的不可伪造性，所有这些必须来自输入数据库$$x$$——在时间聚合$$(κ)$$中运行的多项式时间有界的管理者不能生成新的有效(消息，签名)对。(只是稍微)更正式地说，一个有效的算法可以产生一个(消息，签名)对的概率是可以用密钥$$vk$$验证的，但不在$$x$$中，这是可以忽略的，所以一个有效的合成器产生的任何$$y$$极有可能只包含$$x$$行。这与隐私(任何合理的概念)相矛盾。

​	在这种结构中，$$Qκ$$(验证密钥集)和$$Xκ$$(消息、签名对集)都很大($$κ$$中的超级多项式)。当两个数据集都很小时，合成数据集的高效差异私有生成是可能的。也就是说，有一个差分专用合成程序，其运行时间是$$n  =  κ$$、$$|Qκ|$$和$$|Xκ|$$中的多项式:使用拉普拉斯机制计算噪声计数，以获得概要，然后运行第6节中的合成程序。因此，当这两者都在$$κ$$中具有大小多项式时，合成器的运行时间在$$κ$$中是多项式。

​	我们现在简要讨论第一个硬度结果推广到这些集合中的一个很小(但另一个仍然很大)的情况。

**合成困难的分布2**

​	在上面的数据库分布中，我们选择了单个$$(sk，vk)$$密钥对，并生成了一个信息的数据库，全都使用$sk$签名，困难的获得是在要求合成者在$sk$下生成一个新的签名，以便合成数据库为查询$q$$_v$$_k$提供准确的答案。当查询集的大小在安全参数中为多项式大小时，我们再次使用唯一的密钥签名的数字签名，但是我们不能为每个可能的验证密钥$vk$进行查询，因为这些太多了.

​	为了解决这个问题，我们做了两个改变：

1. 数据库行现有表单（验证密钥，消息，签名）。更准确的说，数据世界由（密钥，消息，签名）三元组$X = {(vk, m, s) : vk ∈ VKκ, m ∈
   \{0,1\} ℓ(κ), s ∈ \{0,1\}ℓs(κ)}.$组成。

2. 我们将$2p_k$查询添加到查询类中，其中$p_v(k)$是通过运行生成算法$Gen(1^k)$生成的验证密钥的长度。查询形式为$(i,b)$,其中$1<=i<=p_v(k)\ b∈ \{0,1\}$.查询$(i,b)$的意思是，数据库行的哪一部分形式是$(vk,m,s)$,其中$Verify(vk,m,s) = 1$,且$vk$的第$i$位是$b$？通过根据单个密钥$vk$签名的消息填充数据库，我们确保当$vk_i = b$时对所有$1<=i<=p(k)$的查询的响应应该接近1，当$vk_i = 1-b$时接近0.

   考虑到这一点，数据库上难以合成的分布是通过以下采样过程构建的：生成签名-验证密钥对$(sk, vk) ← Gen(1κ)$,并选择$n=k$,消息$m_1,...,m_n$均匀来自$\{0,1\}^l$$^($$^k$$^)$.数据库$x$中将有$n$行，对$j ∈ [n]$第$j$行是验证密钥，第$j$个消息及其有效签名，即元组$(vk，m_j，Sign(m_j，sk))$。接下来，从$[n]$中均匀选择$i$。要生成第$(n +  1)$个项目$x'_i$，只需生成一个新的消息签名对(使用相同的密钥$sk$)。

   

   **难以合成的分布3**  为了证明多项式$(in\ k)$大小的消息空间（但超级多项式大小的查询集）情况下的困难，我们使用伪随机函数。粗略地说，这些少量描述的多项式时间可计算函数，仅基于他们的输入输出行为，不能有效地与真正随机的函数（其描述很长）区分开来。如果我们坚持维护所有查询的效用，这个结果只会给合成增加难度。事实上，如果我们只对保证平均效用感兴趣，那么在第6节中描述的用于技术查询的基本生成器产生了一个有效的算法，用于当域$X$是多项式大小时进行合成，即使当$Q$是指数级别时。

   ​	设$\{ f_s \} s∈\{ 0，1\}^κ$是从$[ℓ]$到$[ℓ]$的一族伪随机函数，其中$  ℓ∈poly(κ)$。更具体地说，我们需要[ℓ]中所有元素对的集合是“小的”，但大于$$κ$$；这样，描述函数族的$$κ$$位字符串比描述随机函数映射$$[ℓ]$$到$$[ℓ]$$所需的$$ℓlog2ℓ$$位更短.这种伪随机函数族可以由任何单向函数构成.

   ​	我们的数据世界将会是$[ℓ]:
   X = {(a, b) : a, b ∈ [ℓ]}$中所有元素对的集合。$Q_K$将包含两种类型的查询：

   ​	1.对于族中的每个函数$\{ f_s \} s∈\{ 0，1\}^κ$都会有一个查询。一个元素$(a,b)∈ X$满足查询$s$当且仅当$f_x(a)=b$.

   ​	2.会有一个相对较小的数字，比如$k$，真正的随机查询。这样的查询可以通过随机选择构造，每个$(a，b) ∈ X$，$(a，b)$是否满足查询。

   ​	难以合成的分布生成如下。首先，我们选择一个随机字符串$s∈\{ 0，1 \}^κ$，指定我们族中的一个函数。接下来，对于$$n =  κ$$，我们生成不同的值$a_1,...,a_n$从[ℓ]中随机抽取而不替换，元素$$(a，f_s(a))$$。

   ​	直觉很简单，只依赖于第一种类型的查询，而不利用$a_i$的可区分性。给定一个根据我们的分布生成的数据库$X$，其中伪随机函数由$s$给出，合成器必须创建一个合成数据库(几乎)所有的行都必须满足查询$s$。直觉是，它不能可靠地找到不在$x$中出现的输入输出对。更准确地说，对于任意元素$$a  ∈  [ℓ]$$，使得$x$中没有行是$$(a，f_s(a))$$的形式，$f_S$的伪随机性表明，一个有效的合成器应该超过$1/ℓ$的概率找$f_s(a)$。从这个意义上说，伪随机性给我们提供了类似于我们从数字签名中获得的属性，尽管有些弱。
   
   ​	当然，对于任何给定的$$a ∈  [ℓ]$$，合成者确实可以以$$1/ℓ$$的概率猜测$$f_s(a)$$的值，所以如果没有第二种类型的查询，没有什么明显的东西可以阻止它忽略$x$，选择任意的$a$，并输出$$(a，b)$$的$n$个副本的数据库，其中$b$是从$$[ℓ]$$统一随机采样的。现在的直觉是，在真正随机的查询中，这样一个合成数据库会给出错误的分数——零或一，而正确答案应该大约是$1/2$。
   
   ​	正式地，我们有:
   
   ​	定理 9.1 设$$f : \{0，1\}^κ→ \{0，1\}^κ$$为单向函数。对于每一个$$a > 0$$，并且对于每一个整数$$n =  poly(κ)$$，存在大小为$$exp(poly(κ))$$的查询族$$Q$$，大小为$O(n^2$$^+$$^2$$^a$)数据空间$$X$$，以及大小为$n$的数据库上的分布，即对$$α≤1/3，β  ≤ 1/10$$并且$\mu= 1/40n^1$$^+$$^a$的$(\mu, α, β,0,Q)$难以合成的查询(即，对于最坏情况的查询难以合成)。
   
   ​	上述定理显示了用合成数据进行清洗的难度。但是，请注意，当查询集很小时，您总是可以简单地为每个查询释放有噪声的计数。我们得出结论，对小查询类(具有大数据空间)进行清理是一项将有效的合成与有效的概要生成(对任意输出进行清理)分开的任务。

9.2.1 一般概要的困难结果

​	前面部分的困难结果仅适用于合成程序——创建合成数据库的离线机制。在更一般形式的隐私保护离线机制(我们一直称之为离线查询释放机制或概要生成器)与叛逆者追踪方案的存在之间有着紧密的联系，叛逆者追踪方案是一种内容分发方法，其中(短)密钥串以这样一种方式分发给订阅者，即发送者可以广播可由任何订阅者解密的加密消息，由恶意订阅者联盟构建的任何有用的“盗版”解码器可以被追踪到至少一个串通者。

​	一个(私钥，无状态)叛逆者追踪方案包括算法设置，加密，解密和追踪。设置算法为广播者产生一个密钥$$bk$$和N个用户密钥$$k_1，...，k_N$$。加密算法使用广播者的密钥$$bk$$加密给定的位。解密算法使用任何用户密钥解密给定的密文。跟踪算法获取密钥$$bk$$和对(盗版的，无状态的)解密盒的访问，并输出索引i  ∈ {1，.。。，N}个用来制作盗版盒子的钥匙。

定义9.3。如上所述的方案(建立、加密、解密、追踪)是一个抗攻击的叛逆者跟踪方案，如果(1)它生成的密文在语义上是安全的(粗略地说，多项式时间算法不能区分0的加密和1的加密)，并且(2)在接下来的游戏中，没有多项式时间的对手A能以不可忽略的概率“赢”(通过硬币设定、A和追踪)：

​	$A$接收用户数$$N$$和安全参数$$κ$$，并且(自适应地)请求多达$$t$$个用户$${i_1,...，t_t}$$。然后对手输出一个盗版解码器Dec .  Trace算法用密钥$$bk$$和黑盒访问到Dec；它输出用户的名字$i ∈ [N]$或错误符号$$⊥$$.我们说敌手$A$获胜，如果既是Dec在解密密文方面具有不可忽略的优势(甚至比创建可用的盗版解密设备更弱的条件)，并且$$Trace$$的输出不在$${i_1，...，i_t}$$，意味着对手避免了被发现。

为什么叛逆者追踪方案暗示了计算查询释放的困难结果的直觉如下。固定叛徒追踪方案。我们必须描述数据库和计数查询，对于这些查询，查询释放在计算上是困难的。

​	对于任意给定的$$n = κ$$，数据库$x∈\{\{ 0，1 \}^ d  \} ^n$将包含来自$$n$$个用户的共谋集合的叛逆者追踪方案的用户密钥；这里$d$是在输入$$1^κ$$时运行$Setup$算法时获得的解密密钥的长度。查询族$$Qκ$$将对每个可能的密文$$c$$有一个查询$$q_c$$，询问“对于行$i ∈ [n]$的哪一部分，$c$在$i$行的密钥下解密为1？”请注意，由于每个用户都可以解密，如果发送方分发位1的加密$c$，答案将是1:所有行解密$c$到1，因此这样的行的分数是1。相反，如果发送者分发位0的加密$$c’$$，答案将是0:由于没有行解密$$c’$$到1，解密$$c’$$到1的行的分数是0。因此，对于查询$$q_c$$的准确答案是$$b$$本身，其中$$c$$是1位消息$b$的加密。

​	现在，假设对$$Q$$中的查询有一个有效的离线差分隐私查询释放机制。串通者可以使用该算法来有效地生成数据库的概要，使数据分析师能够有效地计算$$qc$$查询的近似答案。如果这些近似值不是微不足道的，那么分析师可以使用它们来正确解密。也就是说，勾结者可以利用这一点来形成一个盗版解码器盒。但是叛逆者追踪确保，对于任何这样的盒子，追踪算法可以恢复至少一个用户的密钥，即数据库的一行。这违反了差分隐私，与存在用于释放$$q$$的高效差分隐私算法的假设相矛盾。

​	该方向已被用于排除针对特定类别的$2$$ ^O$$ ^($ $ ^√$ $ ^2$  $ ^)$计数查询的高效离线清理程序的存在；这可以扩展到排除有效的在线杀毒程序$Θ(n^2)$的存在，该杀毒程序回答来自第二(大)类的自适应计数查询。

​	为什么离线查询发布对于计算查询的困难意味着叛逆者追踪的直觉是，未能保护隐私会立即产生某种形式的可追溯性；也就是说，提供一个为一组行(解密密钥)产生(近似)功能等价的对象，同时保持每一个单独行(解密密钥)的私密性的困难——也就是产生一个不可追踪的解码器的困难——正是我们在叛逆者追踪方案中寻找的.

​	更详细地说，给定一个难以净化的数据库分布和一系列计数查询，随机抽取的$n$项数据库可以充当“主密钥”，其中用于解密消息的秘密是该数据库上随机查询的计数。对于随机选择的多组($n$)查询子集$S$，从数据库中随机抽取的一组多组($n$)行(非常可能)产生对$S$中所有查询的良好近似。因此，可以通过将数据库随机划分成$$n/多组(n)$$多组($n$)行并将每组分配给不同的用户来获得单个用户密钥。这些集合足够大，以至于它们在随机收集的比如$$polylog(n)$$查询中的计数都接近原始数据库的计数。

​	为了完善这个论点，我们设计了一个加密方案，在这个方案中，解密相当于计算小组随机查询的近似计数。因为根据定义，盗版解密盒可以解密，所以盗版解密盒可以用来计算近似计数。如果我们把这个盒子看作是数据库的净化，我们就可以得出结论(因为净化是困难的)，解密盒子可以“追踪”到用来创建它的密钥(数据库项目)。

9.3 多项式时间对手

定义9.4 （计算差分隐私） 一个随机算法$Cκ: X^n→ Y$是$ε$-计算差分隐私的当且仅当对数据库$x,y$仅有一行不同，且对所有非均匀多项式算法$T(in\ k)$:
$$
Pr[T(C_κ(x)) = 1] ≤ e^εPr[T(C_κ(y)) = 1] + ν(κ),
$$
其中$v(.)$是比任何多项式的逆增长更慢的任意函数，且算法$C_k$在$(n,log|X|,k)$的时间多项式中运行。

​	直观地说，如果对手被限制在多项式时间内，那么计算上差分隐私机制提供了与$$(ε，ν(κ))$$-差分隐私算法相同的隐私程度。一般来说，没有希望去掉$$ν(κ)$$项；例如，当涉及加密时，总是有一些(非常小的)机会猜测解密密钥。

​	一旦我们假设对手被限制在多项式时间内，我们就可以使用强大的安全多方计算技术来提供分布式在线查询释放算法，用模拟可信管理员的分布式协议来代替可信服务器。因此，例如，一组医院，每个医院保存许多患者的数据，可以协作地对他们的患者联盟进行统计分析，同时确保每个患者的不同隐私。一个更激进的含义是，个人可以维护自己的数据，选择加入或退出每个特定的统计查询或研究，同时确保自己数据的不同隐私。

​	我们已经看到了一种分布式解决方案，至少对于计算$n$位总和的问题:随机响应。该解决方案不需要计算假设，期望误差为$$θ(√n)$$。相比之下，加密假设的使用允许更精确和更广泛的分析，因为通过模拟管理者，它可以运行拉普拉斯机制的分布式实现，该实现具有恒定的期望误差。

​	这导致了一个自然的问题，即是否有其他方法，不依赖于密码假设，在分布式环境中比随机响应产生更好的准确性。或者更一般地说，计算差异隐私和“传统”差异隐私之间有什么区别吗？也就是说，密码学能给我们带来什么吗？

​	在多方参与的情况下，答案是肯定的。仍然将我们的注意力限制在对$n$位求和上，我们有:

定理9.2 对于$ε < 1$，每一个用于计算$n$位（一方一位）之和的$n$方$(ε,0)$-差分隐私协议都有高概率导致错误$Ω(n1/2)$.

一个类似的定理适用于$(ε, δ)$-差分隐私，其中$δ∈o(1/n)$.

证明。（概要）设$X1, . . . , Xn$均匀独立位。该协议的转化版$T$是一个随机变量$$T = T(P1(X1)，。。。，Pn(Xn)$$，其中对于$$i ∈  [n]$$玩家$i$的协议表示为$$Pi$$。考虑$T =  t$，位$$X_1，...，X_n$$仍然是独立的位，每个都带有偏置$$O(ε)$$。此外，通过差分隐私，Xi的均匀性，和贝叶斯定律，我们有:


$$
\frac{Pr[Xi= 1|T = t]}
{Pr[Xi= 0|T = t]}=\frac{Pr[T = t|Xi= 1]}
{Pr[T = t|Xi= 0]}≤ e^ε< 1 + 2ε.
$$
为了完成证明，我们注意到$n$个独立位的和，每个位有恒定的偏差，高概率落在任何大小为$ o(√n)$的区间外。因此很有可能，和 $∑
_iXi$很有可能不在区间$[output(T) − o(n^1$ $^/$ $^2$$^)$$,output(T) + o(n^1$$$^/$$ $^2$$)]$.

​	一个更复杂的证明表明，即使在双方的情况下，计算差分隐私和普通差分隐私也是分开的。这是一个引人入胜的开放问题，在可信的管理员的情况下，计算假设是否是我们相信了任何东西。最初的结果是否定的:对于少量的实值查询，也就是说，对于不随安全参数增长的大量查询，有一个自然的效用度量类别，包括$Lp$距离和均方误差，对于这一类别，任何计算上私有的机制都可以转换为统计上私有的机制，该机制具有大致相同的效率并实现几乎相同的效用。

